info.papyri.dispatch.browse.facet.FacetBrowser - Overview
==========================================================

Although the domain model for the faceted browser is complex, the browser code itself is in outline simple.

The reason for this simplicity is that at its core the browser is simply leveraging the power of [baked-in Solr faceting capacities](http://wiki.apache.org/solr/SolrFacetingOverview "Solr faceting overview"). The code therefore does not need to manage basic housekeeping or low-level tasks, and is simply responsible for translating requests made via the interface to Solr queries and then formatting and displaying the results.

Because of this simplicity, the code does not implement design patterns on a large scale, or adhere to any architectural pattern such as Model-View-Controller (MVC). 

However, for ease of explication, the operation of the code is first discussed in MVC terms, in order to clarify the subsequent class and sequence explanations given.

MVC Analysis
============

Model
-----

As noted above, the model layer is taken care of by Solr. It is thus most readily understood by looking at the Solr server's [schema.xml](https://github.com/papyri/navigator/blob/master/pn-solr/pn-search/conf/schema.xml "schema.xml on github") file, and in particular at the fields defined there.

It should be noted, however, that although Solr deals with faceting on a field-by-field basis, individual Java `Facet` classes may sometimes be responsible for two or more fields, which are wrapped and presented to the user as a single control group or facet. The `IdentifierFacet`, for instance, mediates eleven separate fields concerned with identifiers (apis\_series, ddbdp\_series, hgv\_series, etc.); the `HasTranscriptionFacet`, by contrast, deals only with the single Boolean `has_transcription` field.

Controller
----------

The Controller layer is the almost exclusive province of the Java code, and is chiefly dealt with by the `Facet` class. In cases in which a `Facet` maps onto more than one field (and, correspondingly, more than one HTML control is often involved) private internal classes are used to break field interactions down into more tractable subgroups; examples include the `IdentifierFacet.SearchConfiguration` and `DateFacet.Terminus` classes and their subclasses.

The exception to the rule that control is managed by the servlet is the [guidesearch.js](https://github.com/papyri/navigator/blob/master/pn-site/js/guidesearch.js "guidesearch.js on github") tidyQueryString() function. 

The primary role of this function is to eliminate the submission of default values and make the query-string more legible; in addition it performs a number of other minor tasks, such as determining control priority in cases in which more than one HTML control can be used to set a single value. Under most circumstances, then, it has an ideally transparent filtration function - but attention must be paid that the function is indeed passing values along as expected. In particular problems that apparently manifest as failures of state ('apparently' because the servlets are stateless) are generally the result of problems in the tidyQueryString() method.

In addition, the Javascript file [typegreek.js](https://github.com/papyri/navigator/blob/master/pn-site/js/typegreek.js "typegreek.js on github") is responsible for converting standard Latin-alphabet text to Betacode when required.

View
----

The View layer is split across three separate tiers:

1. HTML/CSS (all in the pn-site directory)
2. JavaScript. The role of JS in the View layer is small but important - ensuring, for instance, that the navigation bar is correctly aligned and allowing the search panel to be hidden and revealed.
3. The Java layer. While overall layout and appearance is controlled by static HTML and CSS, the majority of the underlying HTML is generated by the servlet itself. In particular:
 1. `<Facet>.generateWidget` and `<Facet>.generateHiddenFields` are responsible for generating controls for each of the individual facets.
 2. The `DocumentBrowseRecord` class is responsible for generating HTML summaries of the documents returned.
 3. The `FacetBrowser` class has a number of View-level methods, including:
     1. `assembleWidgetHTML`, which gathers together and wraps the widget-generating output of each of the `Facet`'s `generateWidget` method.
     2. `assemblePreviousValuesHTML`, which generates controls for the display and/or removal of previously set values.
     3. `assembleRecordsHTML`, which gathers together and wraps the summaries output by the `DocumentBrowseRecord.getHTML` method.
     4. `doPagination`, in cases where the number of records returned exceeds the number displayed per page.
     5. `displayBrowseResult`, responsible for injecting the aggregate HTML produced by the above four methods into a [pre-existing HTML page](https://github.com/papyri/navigator/blob/master/pn-site/facetbrowse.html "facetbrowse.html on github")
    	
Anything more than trivial changes to the View will accordingly require alteration of the underlying Java code. Although the practice of encoding HTML at the servlet level is often frowned upon, it should be noted that the highly dynamic character of the application and the specialised character of each of the facets means that a templating solution (i.e., one in which a clean separation between View and Controller is made) is not appropriate here.

Class Description
=================

The operations of the facet browser can be understood at a bird's-eye view as relying on only three groups of classes:

1. `info.papyri.dispatch.browse.facet.FacetBrowser`. This class is responsible for initial handling of the request, for final output, and for co-ordinating interactions among the individual `Facet` objects. Note, however, that this co-ordination is very simple, typically consisting only of iterating through the `Facet`s in turn and calling some (polymorphic) method upon each of them.
2. `info.papyri.dispatch.browse.DocumentBrowseRecord`. Faceted browsing interactions depend upon two batches of information being returned from the server: first, the items that match the value specified in the request; and second, which facet values are now available now that the search scope has been narrowed to this set of items. The `DocumentBrowseRecord` class is concerned with the first group - the items retrieved. The `FacetBrowser`, in other words, parses the response it gets from the Solr server into `DocumentBrowseRecord` objects, which are responsible for their own HTML output and formatting.
3. `info.papyri.dispatch.browse.facet.Facet` and its subclasses. This is where most of the action takes place: each `Facet` subclass is responsible for knowing what fields in the model it relates to, how these fields should be processed, how they should be displayed, and what controls are appropriate to them. This is also the messiest part of the code: one-off exceptions and special cases abound in The Gory Details of these classes.

Sequence Description
====================

The following is only a (very) schematic overview. For more specific descriptions, see the javadoc documentation for the classes in question. (need to supply link here).

1. A request is passed to the`info.papyri.dispatch.browse.facet.FacetBrowser`  object
2. The `FacetBrowser` instantiates each `Facet` subclass.
3. The `FacetBrowser` then passes the request around to each of the `Facet`s in turn. Each `Facet` inspects the request to determine whether it holds relevant constraint(s). if it does, these are stored.
4. The `FacetBrowser` creates a new `SolrQuery` object, and passes it around to each `Facet` in turn.
5. Each `Facet` adds the facet fields in which it is interested as specifiers to the `SolrQuery` object. In addition, if a constraint has been set upon it, this constraint is added to the `SolrQuery` as a filter query.
6. The `FacetBrowser` submits the now-qualified `SolrQuery` object to the Solr server and receives a `QueryResponse` in return.
7. The `FacetBrowser` now passes the `QueryResponse` to each `Facet` in turn.
8. Each `Facet` draws the facet values relevant to itself from the `QueryResponse`, and uses them to populate its control widget(s).
9. The `SolrDocument`s returned in the `QueryResponse` are parsed into `DocumentBrowseRecord` objects by the `FacetBrowser`.
10. The `FacetBrowser` calls the `generateWidget` method of each of the `Facet`s to get the HTML for each facet control.
11. The `FacetBrowser` generates whatever HTML is required to display previous values.
12. The `FacetBrowser` calls the `generateHTML` method of each `DocumentBrowseRecords` for the HTML summaries required for each returned document.
13. The `FacetBrowser` outputs the assembled HTML to the user, who is now in a position to submit further values and begin the process again.
